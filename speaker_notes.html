<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>speaker_notes</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="speaker_notes_files/libs/clipboard/clipboard.min.js"></script>
<script src="speaker_notes_files/libs/quarto-html/quarto.js"></script>
<script src="speaker_notes_files/libs/quarto-html/popper.min.js"></script>
<script src="speaker_notes_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="speaker_notes_files/libs/quarto-html/anchor.min.js"></script>
<link href="speaker_notes_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="speaker_notes_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="speaker_notes_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="speaker_notes_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="speaker_notes_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="title-slide" class="level2">
<h2 class="anchored" data-anchor-id="title-slide">Title slide</h2>
<p>Thank you for allowing us to showcase our prototype in the space webinar series.</p>
<p>Sebastian has presented the scientific background and potential applications, while I will focus more on the technical design and implementation.</p>
<p>My scientific background is in quantum chemistry.</p>
<p>However, I have been working for almost 20 years as a software engineer, covering topics in HPC and machine learning using C++, CUDA, Python, and many others.</p>
</section>
<section id="outline" class="level2">
<h2 class="anchored" data-anchor-id="outline">Outline</h2>
<p>I will introduce our development setup, which respects the FAIR principles, and try to use the best available techniques for software lifecycle development.</p>
<p>Then, I will introduce the Spherinator model and explain its training process.</p>
<p>Afterward, the trained model is used in the so-called HiPSter workflow to construct inferences to display the modeled galaxies and dataset projections.</p>
</section>
<section id="fair-principles" class="level2">
<h2 class="anchored" data-anchor-id="fair-principles">FAIR principles</h2>
<p>Allow me to begin by making a general statement about the FAIR principles in research software.</p>
<p>Our goal is to adhere to these principles as closely as possible.</p>
<p>These principles state that the software should be easily findable and accessible, interact with other software through open standards, and be simple to use and modify.</p>
</section>
<section id="development-environment" class="level2">
<h2 class="anchored" data-anchor-id="development-environment">Development environment</h2>
<p>We have established a development environment using GitHub that covers the entire software lifecycle, from feature design to deployment, with GitHub Actions providing continuous integration.</p>
<p>For dependency management, we use Poetry, and Dependabot is used to automate version updates.</p>
<p>The models will be converted into the ONNX open source standard, enabling interoperability among ML frameworks and programming languages.</p>
<p>We use Weights &amp; Biases to track and orchestrate the training process.</p>
<p>This development setup complies with the FAIR principles, providing stability while allowing for necessary flexibility to make steady improvements.</p>
</section>
<section id="the-model" class="level2">
<h2 class="anchored" data-anchor-id="the-model">The model</h2>
<p>The Spherinator model is built on dimensionality reduction, which allows it to learn data features automatically.</p>
<p>To achieve this, we use a generative model known as a convolutional variational autoencoder.</p>
<p>This is an unsupervised approach that enables us to generate new data by identifying patterns in existing data.</p>
<p>Unlike the plain autoencoder, which reconstructs images from a single point in the latent space, the VAE uses a sample from a learned distribution.</p>
<p>As a result, the neighborhood in the latent space represents similar features. The rotational invariance is crucial for learning features from galaxy images, as they should not be dependent on image rotation.</p>
<p>Thus, the image with the lowest reconstruction loss is selected, and only that image is used for the training step.</p>
<p>The term “Spherinator” is derived from the spherical latent space manifold.</p>
<p>It is possible to have other manifolds, but the spherical manifold is the most suitable for visualizing later.</p>
</section>
<section id="the-power-spherical-distribution" class="level2">
<h2 class="anchored" data-anchor-id="the-power-spherical-distribution">The Power spherical distribution</h2>
<p>The power spherical distribution published in 2020 provides a reliable method to handle spherical latent space.</p>
<p>Here, the direction represents the position in the latent space, and kappa is a measure of the distribution function’s width.</p>
<p>The dimension of a circle is 2, a sphere is 3, and hyperspheres have a dimension greater than 3.</p>
</section>
<section id="the-loss-function" class="level2">
<h2 class="anchored" data-anchor-id="the-loss-function">The Loss Function</h2>
<p>The loss function consists of the reconstruction loss and the Kullback-Leibler divergence.</p>
<p>The reconstruction loss is calculated using a pixel-wise Euclidean distance.</p>
<p>The Kullback-Leibler divergence measures the difference between the power spherical distribution function and a reference distribution function.</p>
<p>In the Euclidean space, the reference function is a centric Gaussian distribution, whereas a uniform distribution is used in the spherical case.</p>
<p>It is crucial to find the right balance between these two parts of the loss function</p>
<p>This is achieved by the factor lambda, which scales down the Kullback-Leibler divergence.</p>
</section>
<section id="the-training" class="level2">
<h2 class="anchored" data-anchor-id="the-training">The training</h2>
<p>For the training, <strong>PyTorch Lightning</strong> is used, which decouples research from the engineering code. It is easier to read, shows better reproducibility, and can scale up using accelerated and distributed hardware.</p>
<p>With the command line interface of PyTorch Lightning, everything is defined in a single file. The classpath and its arguments define the model.</p>
<p>It is also possible to use further models in the arguments, for example, for the encoder and decoder. So it’s easy to integrate existing models, for example, Resnet or Visual Transformer as encoder part.</p>
<p>The most excellent section is the trainer part: You can switch on the GPU accelerator with a single line. With another line, you can control the number of GPUs used.</p>
<p>Here, it is also possible to add loggers like Weights&amp;Biases, Callbacks, Profiler, and so on.</p>
</section>
<section id="monitoring-the-training" class="level2">
<h2 class="anchored" data-anchor-id="monitoring-the-training">Monitoring the training</h2>
<p>The AI platform Weights&amp;Biases is a comfortable way to track the training experiments. The data can be shared with the research team.</p>
<p>The trained models can be organized and version-controlled in the model registry, from where they can be used for fine-tuning, staging, or production.</p>
<p>So, searching for and copying the correct model is no longer needed.</p>
<p>Weights&amp;Biases provides also a hyperparameter optimization, and it’s free for academic research.</p>
</section>
<section id="hipster-the-inference" class="level2">
<h2 class="anchored" data-anchor-id="hipster-the-inference">HiPSter: The Inference</h2>
<p>As the next step, we would like to visualize the generated images from the latent space with the trained model.</p>
<p>Here, the hierarchical progressive survey, the HiPS format, opens an ideal way to visualize the spherical manifold hierarchically, where we can zoom into the latent space and get more generated images in this region.</p>
<p>With the HiPS file structure, we can use the excellent program Aladin-Lite for the final visualization.</p>
</section>
<section id="hipster-the-workflow" class="level2">
<h2 class="anchored" data-anchor-id="hipster-the-workflow">HiPSter: The Workflow</h2>
</section>
<section id="summary-and-outlook" class="level2">
<h2 class="anchored" data-anchor-id="summary-and-outlook">Summary and Outlook</h2>
<p>We have seen that Spherinator and HiPSter provide a promising solution for classifying large datasets.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>